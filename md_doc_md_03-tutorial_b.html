<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Expected&lt;T, E&gt; in Practice</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_03-tutorial_b.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expected&lt;T, E&gt; in Practice </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#expected_simple_e_is_bad">Simple E types in expected<T, E> is bad practice in C++</a></li>
<li class="level1"><a href="#custom_error_codes">Marking up your custom error code domain so the STL understands it</a></li>
<li class="level1"><a href="#expected_tension">The tension between type safety and convenient programming</a><ul><li class="level2"><a href="#try_operation">The TRY operation</a></li>
</ul>
</li>
<li class="level1"><a href="#expected_payload">Sending payload with your custom error type</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial_whynot"></a></p>
<p>Outcome's design rationale and tutorial is split into three parts:</p>
<ol type="1">
<li>The <a class="el" href="md_doc_md_02-tutorial_a.html#tutorial_expected">first part</a> provides a broad overview of error handling in C++ in general and how the <code>expected&lt;T, E&gt;</code> proposed for standardisation will contribute to that big menu of error handling design patterns available to the C++ programmer. This part places Outcome the library in context.</li>
<li>The second part (this part) describes some design anti-patterns common with inexperienced usage of <code>expected&lt;T, E&gt;</code> in C++ which you ought to avoid. It shows you how to use <code>expected&lt;T, E&gt;</code> in a way which integrates well with the C++ 11 STL's standard error code facilities <code>std::error_code</code> and <code>std::error_category</code>.</li>
<li>The <a class="el" href="md_doc_md_04-tutorial_c.html#tutorial_outcome">third part</a> walks you through using Outcome's <code>expected&lt;T, E&gt;</code> refinements <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, plus its <code>extended_error_code</code>. Usage is very similar to Expected, but with less typing, less runtime overhead and more convenient extensions.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_simple_e_is_bad"></a>
Simple E types in expected&lt;T, E&gt; is bad practice in C++</h1>
<p>Most people very keen on Expected entering C++ will be coming from a Swift or especially Rust background where when you use <code>Result&lt;T, E&gt;</code>, you invariably supply a bespoke enum of error codes for type <code>E</code> like this fragment of Rust:</p>
<div class="fragment"><div class="line">pub <span class="keyword">enum</span> MathError {</div>
<div class="line">  DivisionByZero,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  NegativeSquareRoot,</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">pub type MathResult = Result&lt;f64, MathError&gt;;</div>
</div><!-- fragment --><p>I will tell you now that this is a <b>bad idea</b> in large C++ codebases or in any code expected to be used by others, and you should not do this with <code>expected&lt;T, E&gt;</code>.</p>
<p>The first reason is because C++ 11 brought in an infrastructure from Boost which allows you to <em>non-intrusively</em> mark up <b>any</b> arbitrary third party error code system to tell the C++ standard library about it such that any other C++ code using that system can handle any third party error situation <em>without being recompiled</em> and <em>without losing information</em>. If you refuse to use the C++ 11 standard way of working with error codes, then you are being <b>anti-social</b> to other C++ code and devaluing the experience of anybody else who works with your code. Moreover, it is extremely easy to do the right thing and use the standard C++ 11 infrastructure for error codes, and a worked example follows below.</p>
<p>The second reason is that if everybody goes off and locally defines their own custom error code system, you force programmers coming later to your code to deal with a multitude of local error code domains which may or may not mean the same thing. Expect a multiplication of lots of little switch statements mapping one small domain of error code to another, all of which must be maintained and parsed by programmers coming later to your codebase. The growing maintenance burden over time is obvious, and a further worked example follows below.</p>
<p>The third reason is that the C++ 11 standard library already provides an enum of the most common error codes for you so you don't feel like going off and reinventing the wheel. It's called <a href="http://en.cppreference.com/w/cpp/error/errc"><code>std::errc</code></a> brought in by <code>include &lt;system_error&gt;</code> and as you'll see, it contains the standard POSIX error codes, and most of the time you'll find that whatever custom error code domain you are about to write can be adequately covered by <code>std::errc</code>. In fact, let's try it:</p>
<div class="fragment"><div class="line"><span class="comment">// Mathematical &quot;errors&quot; we want to catch</span></div>
<div class="line"><span class="keyword">using</span> MathError = std::error_code;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> MathError DivisionByZero = std::make_error_code(std::errc::result_out_of_range);</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> MathError NegativeLogarithm = std::make_error_code(std::errc::argument_out_of_domain);</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> MathError NegativeSquareRoot = std::make_error_code(std::errc::argument_out_of_domain);  </div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> MathResult = outcome::expected&lt;double, MathError&gt;;</div>
</div><!-- fragment --><p>Anything which can "speak" <code>std::error_code</code> can now work perfectly with your error code system because you are using a standard error code domain (i.e. the POSIX error code domain). And for reference, the C++ 11 STL ships with these ready to go predefined error categories and error enumerations:</p>
<dl>
<dt><a href="http://en.cppreference.com/w/cpp/error/generic_category"><code>std::generic_category()</code></a> with corresponding enumeration <a href="http://en.cppreference.com/w/cpp/error/errc"><code>std::errc</code></a> </dt>
<dd>The POSIX standard error code domain as retrieved by the <code>errno</code> variable after calling a POSIX function. </dd>
<dt><a href="http://en.cppreference.com/w/cpp/error/system_category"><code>std::system_category()</code></a> with a platform specific enumeration </dt>
<dd>The "usual" error code domain for your particular host OS, so on Linux/FreeBSD/OS X/Android this is the exact same domain as <code>generic_category()</code>. On Microsoft Windows this is the error code domain as returned by the Win32 <code>GetLastError()</code> function. Other platforms can vary. </dd>
<dt><a href="http://en.cppreference.com/w/cpp/io/iostream_category"><code>std::iostream_category()</code></a> with corresponding enumeration <a href="http://en.cppreference.com/w/cpp/io/io_errc"><code>std::io_errc</code></a> </dt>
<dd>The STL iostreams error code domain. </dd>
<dt><a href="http://en.cppreference.com/w/cpp/thread/future/future_category"><code>std::future_category()</code></a> with corresponding enumeration <a href="http://en.cppreference.com/w/cpp/thread/future_errc"><code>std::future_errc</code></a> </dt>
<dd>The STL future-promise error code domain. </dd>
</dl>
<p>Because <code>std::error_code</code> is the C++ 11 standard way of doing error codes, <code>expected&lt;T, E&gt;</code> defaults <code>E</code> to <code>std::error_code</code> both in the proposed standard [1] and in Outcome's implementation.</p>
<p>The big problem with directly using <code>std::error_code</code> as <code>E</code> is the loss of type safety because <code>std::error_code</code> will accept any input implicitly convertible. So you can write this code and the compiler won't complain:</p>
<div class="fragment"><div class="line"><span class="comment">// Not a valid MathError, yet the compiler won&#39;t stop you doing this</span></div>
<div class="line"><span class="keywordflow">return</span> MathResult(<a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">make_unexpected</a>(std::make_error_code(std::errc::executable_format_error)));</div>
</div><!-- fragment --><p>As is usually the case in C++, fixing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. As how to do this is not well documented [2], next follows a very quick howto guide.</p>
<p>[1]: The current LEWG Expected proposal defaults <code>E</code> to <code>std::error_condition</code>. We believe this almost certainly to be a defect and it ought to be <code>std::error_code</code>.</p>
<p>[2]: The only documentation I'm aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:</p>
<ul>
<li><a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html</a></li>
<li><a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html</a></li>
<li><a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html</a></li>
<li><a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html</a></li>
<li><a href="http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html</a></li>
</ul>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="custom_error_codes"></a>
Marking up your custom error code domain so the STL understands it</h1>
<p>Let's get into it! This is how you tell C++ 11's standard error code infrastructure about your custom <code>expected&lt;T, E&gt;</code> error code type so it works well with anything speaking <code>std::error_code</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;system_error&gt;</span>  <span class="comment">// bring in std::error_code et al</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This is the custom error code enum</span></div>
<div class="line"><span class="keyword">class </span>MathError : <span class="keyword">public</span> std::error_code {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> valid_errors {</div>
<div class="line">    DivisionByZero,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    NegativeSquareRoot</div>
<div class="line">  };</div>
<div class="line">  MathError() = <span class="keywordflow">default</span>;  <span class="comment">// Expected requires E to be default constructible</span></div>
<div class="line">  <span class="comment">// Only allow my construction from my enum</span></div>
<div class="line">  <span class="keyword">inline</span> MathError(valid_errors c);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Define a custom error code category derived from std::error_category</span></div>
<div class="line">  <span class="keyword">class </span>MathError_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Return a short descriptive name for the category</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError&quot;</span>; }</div>
<div class="line">    <span class="comment">// Return what each enum means in text</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// OPTIONAL: Allow generic error conditions to be compared to me</span></div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare a global function returning a static instance of the custom category</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError_category &amp;MathError_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now we have the custom error code category, implement the MathError constructor</span></div>
<div class="line"><span class="keyword">inline</span> MathError::MathError(MathError::valid_errors e) : std::error_code(e, MathError_category()) {}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Overload the global make_error_code() free function with our</span></div>
<div class="line"><span class="comment">// custom enum. It will be found via ADL by the compiler if needed.</span></div>
<div class="line"><span class="keyword">inline</span> MathError <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError::valid_errors e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> MathError(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Tell the C++ 11 STL metaprogramming that enum MathError::valid_errors</span></div>
<div class="line">  <span class="comment">// is registered with the standard error code system</span></div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError::valid_errors&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Note that we can now supply MathError directly to error_code</span></div>
<div class="line">  std::error_code ec(MathError::NegativeLogarithm);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;MathError::NegativeLogarithm is printed by std::error_code as &quot;</span></div>
<div class="line">    &lt;&lt; ec &lt;&lt; <span class="stringliteral">&quot; with explanatory message &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We can compare MathError containing error codes to generic conditions</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ec is equivalent to std::errc::result_out_of_range = &quot;</span></div>
<div class="line">    &lt;&lt; (ec == std::errc::result_out_of_range) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ec is equivalent to std::errc::argument_out_of_domain = &quot;</span></div>
<div class="line">    &lt;&lt; (ec == std::errc::argument_out_of_domain) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:</p>
<ol type="1">
<li>Any code which can speak <code>std::error_code</code> can now work with errors from your code, AND without being recompiled.</li>
<li><code>std::system_error</code> can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception <em>and back out again</em> without losing information.</li>
<li><code>std::error_code</code> knows how to print itself, and will print your custom error code without extra work from you. As usually you'd need to define a print routine for any custom error code you'd write anyway, there is actually very little extra boilerplate here.</li>
<li>If you implement the <code>default_error_condition()</code> override, you can allow code exclusively written to understand <code>std::errc</code> alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.</li>
<li>Type safety is preserved, you cannot construct a <code>MathError</code> from anything but the officially sanctioned enums in <code>MathError</code>.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_tension"></a>
The tension between type safety and convenient programming</h1>
<p>Let's look at another problem which naive direct usage of custom error code enums has: the quantity of boilerplate it makes you write.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>outcome = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom error code domain 1</span></div>
<div class="line"><span class="keyword">enum class</span> MathError1 {</div>
<div class="line">  DivisionByZero,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  NegativeSquareRoot</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Custom error code domain 2</span></div>
<div class="line"><span class="keyword">enum class</span> MathError2 {</div>
<div class="line">  NegativeSquareRoot,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  DivisionByZero</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> MathResult1 = outcome::expected&lt;double, MathError1&gt;;</div>
<div class="line"><span class="keyword">using</span> MathResult2 = outcome::expected&lt;long long, MathError2&gt;;</div>
<div class="line"></div>
<div class="line">MathResult1 div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">    <span class="comment">// the failure wrapped in E</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError1::DivisionByZero);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">    <span class="keywordflow">return</span> x / y;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">MathResult2 div10mul3(<span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  MathResult1 result = div(10.0, y);</div>
<div class="line">  <span class="comment">// If successful, return the result</span></div>
<div class="line">  <span class="keywordflow">if</span> (result)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(result.value() &lt; 0)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError2::NegativeSquareRoot);</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(result.value() * 3.0);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: If it failed, convert the MathError1 error code domain into</span></div>
<div class="line">  <span class="comment">//       the MathError2 error code domain</span></div>
<div class="line">  <span class="keywordflow">switch</span> (result.error())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::DivisionByZero;</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::NegativeLogarithm;</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::NegativeSquareRoot;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; div10mul3(1.0).value() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: the C++ exception type thrown by Expected embeds a copy</span></div>
<div class="line">  <span class="comment">//       of type E and therefore its template signature must</span></div>
<div class="line">  <span class="comment">//       be the correct type E. If we accidentally used MathError1</span></div>
<div class="line">  <span class="comment">//       here the exception would not be caught!</span></div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> outcome::bad_expected_access&lt;MathError2&gt; &amp;e)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;div10mul3().value() threw an exception&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The example is contrived for sure, but it shows the problem of having lots of local custom error code domains. In the above example, <code>MathError2</code> has a different assignment of integer values to <code>MathError1</code>, but they could simply be different error code enums. As is common in any code base of any size, one layer of functions (<code>div10mul3()</code>) will call into an inner layer of more basic functions (<code>div()</code>) and will need to pass back out any errors encountered.</p>
<p>There are two things to note in this example. The first is that due to the error code domains being different, you need to convert error codes using a switch statement. The second is that on bad access, Expected throws a templated exception type with the type <code>E</code> as the template parameter. I can tell you that it is far too easy in the real world to accidentally mistype or forget to update the type caught in the catch statement leading to unintentional bugs which are quite tricky to track down.</p>
<p>Let's try a different approach. What we do now is to hard code our use of <code>expected&lt;T, E&gt;</code> to <code>E = std::error_code</code> which is made easy for us by the fact it's already been defaulted to that for us by Expected's definition:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>outcome = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MathError1 : <span class="keyword">public</span> std::error_code {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> valid_errors {</div>
<div class="line">    DivisionByZero,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    NegativeSquareRoot</div>
<div class="line">  };</div>
<div class="line">  MathError1() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// Only allow my construction from my enum</span></div>
<div class="line">  <span class="keyword">inline</span> MathError1(valid_errors c);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MathError2 : <span class="keyword">public</span> std::error_code {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> valid_errors {</div>
<div class="line">    NegativeSquareRoot,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    DivisionByZero</div>
<div class="line">  };</div>
<div class="line">  MathError2() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// Only allow my construction from my enum</span></div>
<div class="line">  <span class="keyword">inline</span> MathError2(valid_errors c);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">class </span>MathError1_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError1&quot;</span>; }</div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">class </span>MathError2_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError2&quot;</span>; }</div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError1_category &amp;MathError1_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError1_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError2_category &amp;MathError2_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError2_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> MathError1::MathError1(MathError1::valid_errors e) : std::error_code(e, MathError1_category()) {}</div>
<div class="line"><span class="keyword">inline</span> MathError2::MathError2(MathError2::valid_errors e) : std::error_code(e, MathError2_category()) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> MathError1 <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError1::valid_errors e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> MathError1(e);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">inline</span> MathError2 <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError2::valid_errors e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> MathError2(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError1::valid_errors&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError2::valid_errors&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">outcome::expected&lt;<span class="keywordtype">double</span> <span class="comment">/*, std::error_code */</span>&gt; div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">    <span class="comment">// the failure wrapped in E</span></div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected&lt;std::error_code&gt;(MathError1::DivisionByZero);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">    <span class="keywordflow">return</span> x / y;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">outcome::expected&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="comment">/*, std::error_code */</span>&gt; div10mul3(<span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If calling div() fails, return the same error immediately,</span></div>
<div class="line">  <span class="comment">// else unpack the T into r. REQUIRES type E to be identical!</span></div>
<div class="line">  <a class="code" href="group__macro__helpers.html#gaa977bf0b7aded30c781c35f956edc1d7">BOOST_OUTCOME_TRY</a>(r, div(10.0, y));</div>
<div class="line">  <span class="keywordflow">if</span> (r &lt; 0.0)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected&lt;std::error_code&gt;(MathError2::NegativeSquareRoot);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(sqrt(r * 3.0));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; div10mul3(1.0).value() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: Much less likely to become stale accidentally</span></div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> outcome::bad_expected_access&lt;/* std::error_code */&gt; &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Also note we can always print the error code because E is</span></div>
<div class="line">    <span class="comment">// always an error_code</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;div10mul3().value() failed due to &quot;</span> &lt;&lt; e.error() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This eliminates the fragile switch statements converting between error code domains in favour of a information loss free transmission. The cost is once again a loss of type safety because a function might return an error code it should never be able to return and the compiler will not complain.</p>
<p>Mashing together both approaches we can solve the problem of type safety by making <code>MathError2</code> explicitly constructible from <code>MathError1</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>outcome = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MathError1 : <span class="keyword">public</span> std::error_code {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> valid_errors {</div>
<div class="line">    DivisionByZero,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    NegativeSquareRoot</div>
<div class="line">  };</div>
<div class="line">  MathError1() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// Only allow my construction from my enum</span></div>
<div class="line">  <span class="keyword">inline</span> MathError1(valid_errors c);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MathError2 : <span class="keyword">public</span> std::error_code {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> valid_errors {</div>
<div class="line">    NegativeSquareRoot,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    DivisionByZero</div>
<div class="line">  };</div>
<div class="line">  MathError2() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="comment">// Allow my construction from my enum</span></div>
<div class="line">  <span class="keyword">inline</span> MathError2(valid_errors c);</div>
<div class="line">  <span class="comment">// And from MathError1</span></div>
<div class="line">  <span class="keyword">explicit</span> MathError2(MathError1 e) : std::error_code(e) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">class </span>MathError1_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError1&quot;</span>; }</div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">class </span>MathError2_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError2&quot;</span>; }</div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (c)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError2::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError1_category &amp;MathError1_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError1_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError2_category &amp;MathError2_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError2_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> MathError1::MathError1(MathError1::valid_errors e) : std::error_code(e, MathError1_category()) {}</div>
<div class="line"><span class="keyword">inline</span> MathError2::MathError2(MathError2::valid_errors e) : std::error_code(e, MathError2_category()) {}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> MathError1 <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError1::valid_errors e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> MathError1(e);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">inline</span> MathError2 <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError2::valid_errors e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> MathError2(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError1::valid_errors&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError2::valid_errors&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">outcome::expected&lt;double, MathError1&gt; div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">    <span class="comment">// the failure wrapped in E</span></div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected&lt;MathError1&gt;(MathError1::DivisionByZero);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">    <span class="keywordflow">return</span> x / y;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">outcome::expected&lt;long long, MathError2&gt; div10mul3(<span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If calling div() fails, return the same error immediately,</span></div>
<div class="line">  <span class="comment">// else unpack the T into r. Note we cannot use BOOST_OUTCOME_TRY() here</span></div>
<div class="line">  <span class="comment">// as the error types are different.</span></div>
<div class="line">  outcome::expected&lt;double, MathError1&gt; _r = div(10.0, y);</div>
<div class="line">  <span class="keywordflow">if</span> (!_r)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError2(_r.error()));  <span class="comment">// note explicit conversion needed</span></div>
<div class="line">  <span class="keyword">auto</span> r = std::move(_r.value());</div>
<div class="line">  <span class="keywordflow">if</span> (r &lt; 0.0)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected&lt;MathError2&gt;(MathError2::NegativeSquareRoot);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(sqrt(r * 3.0));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; div10mul3(1.0).value() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: Back to becoming easily and silently stale, it&#39;s an unavoidable</span></div>
<div class="line">  <span class="comment">//       consequence of type safety</span></div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> outcome::bad_expected_access&lt;MathError2&gt; &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Also note we can always print the error code because E is</span></div>
<div class="line">    <span class="comment">// always an error_code</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;div10mul3().value() failed due to &quot;</span> &lt;&lt; e.error() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This approach means that <code>MathError2</code> can contain an error code which has nothing to do with <code>MathError2</code>'s enumerations. This may be confusing initially, but you need to consider the compile time and run time separately - this approach comes with compile time safety but without run time safety.</p>
<p>So which approach should you use in your code? It depends on the specific application. If your code base needs to tightly specify all the exact errors which can occur in some function call stack rather similarly to <a href="http://en.cppreference.com/w/cpp/language/except_spec">dynamic C++ exception specifications</a>, then the third example is the form you should use. If your code base is mostly a systems abstraction layer where errors from the OS ought to be returned exactly as from the OS, you should leave <code>E</code> default to <code>std::error_code</code> and return <code>std::system_category()</code> error codes from <code>errno</code> or <code>GetLastError()</code> as appropriate. If you don't care and/or you're in a rush, <code>E = std::error_code</code> and returning some enumeration from <code>std::errc</code> will get you working code the quickest (and be aware that Outcome's refinements of <code>expected&lt;T, E&gt;</code> <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> hard code the <code>E</code> to an enhanced <code>error_code_extended</code> and will save you typing a fair bit of boilerplate). As the latter two use patterns may be unclear, a worked example follows in the next section.</p>
<h2><a class="anchor" id="try_operation"></a>
The TRY operation</h2>
<p>You may have noted the earlier use of the convenience macro <code>BOOST_OUTCOME_TRY(var, expr)</code> which provides some of the <code>try</code> operator in Swift or Rust. The TRY operation evaluates the expression and if the result returned is an unexpected value, it immediately returns from the current function with the same unexpected value - therefore your type <code>E</code> needs to be identical. If it is an expected value, that value is <em>unwrapped</em> and returned as the result from the TRY operation.</p>
<p>Unlike the <code>try</code> operator, the macro is not an expression so you can't write statements like <code>if(BOOST_OUTCOME_TRY(var, expr))</code> as you can in Rust or Swift, this is due to a limitation of the C++ language (you can't return from functions in an expression) [1]. What you can do is to initialise a variable <code>var</code> on the stack to the unwrapped return value from the expression, so you might write:</p>
<div class="fragment"><div class="line">expected&lt;std::string, std::error_code&gt; somefunc();</div>
<div class="line">...</div>
<div class="line">expected&lt;int, std::error_code&gt; someotherfunc()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If somefunc() returns an E, immediately return an</span></div>
<div class="line">  <span class="comment">// expected&lt;int, std::error_code&gt; with the same E</span></div>
<div class="line">  <span class="comment">// as if return make_unexpected(somefunc().error());</span></div>
<div class="line">  <a class="code" href="group__macro__helpers.html#gaa977bf0b7aded30c781c35f956edc1d7">BOOST_OUTCOME_TRY</a>(v, somefunc());</div>
<div class="line">  <span class="comment">// ... else unpack the T into v as if</span></div>
<div class="line">  <span class="comment">// std::string v(std::move(somefunc().value());</span></div>
<div class="line">  <span class="keywordflow">return</span> v.empty() ? 0 : v.size();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you wish to <code>try</code> a function call but not unwrap any returned value, use the <code>BOOST_OUTCOME_TRYV(expr)</code> macro instead.</dd></dl>
<p>[1]: GCC and clang provide a proprietary extension to the language letting you encode a sequence of statements into an expression, so on those compilers only a <code>BOOST_OUTCOME_TRYX(expr)</code> macro behaves exactly like the <code>try</code> operator in Swift or Rust. The <code>BOOST_OUTCOME_TRYX</code> macro is not defined on compilers not supporting that proprietary extension.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_payload"></a>
Sending payload with your custom error type</h1>
<p>One of the most common error types people write with <code>expected&lt;T, E&gt;</code> is <code>expected&lt;T, std::string&gt;</code> so they can return some arbitrary string explaining the error. This is the simplest example of sending runtime <em>payload</em> with the returned error explaining the error. Let's have a look at a typical naive custom error type carrying payload:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span></div>
<div class="line"><span class="keyword">using</span> ssize_t = <span class="keywordtype">long</span> long;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>outcome = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// RAII for an open file handle</span></div>
<div class="line"><span class="keyword">class </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> _fd;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  handle() : _fd(-1) {}</div>
<div class="line">  handle(<span class="keywordtype">int</span> fd) : _fd(fd) {}</div>
<div class="line">  handle(handle &amp;&amp;o) noexcept : _fd(o._fd) { o._fd = -1; }</div>
<div class="line">  handle &amp;operator=(handle &amp;&amp;o) noexcept { this-&gt;~handle(); <span class="keyword">new</span>(<span class="keyword">this</span>) handle(std::move(o)); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line">  <span class="keyword">virtual</span> ~handle() { <span class="keywordflow">if</span> (-1 != _fd) ::close(_fd); }</div>
<div class="line">  ssize_t read(<span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> len) { return ::read(_fd, buffer, len); }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> handle_ref = std::shared_ptr&lt;handle&gt;;</div>
<div class="line"><span class="keyword">inline</span> handle_ref make_handle(<span class="keywordtype">int</span> fd) { <span class="keywordflow">return</span> std::make_shared&lt;handle&gt;(fd); }</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom error type</span></div>
<div class="line"><span class="keyword">struct </span>file_error</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">enum</span></div>
<div class="line">  {</div>
<div class="line">    no_error = 0,</div>
<div class="line">    out_of_memory,</div>
<div class="line">    failure_to_open,</div>
<div class="line">    io_failure,</div>
<div class="line">    format_corrupt</div>
<div class="line">  } code;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *path;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> outcome::expected&lt;handle_ref, file_error&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error{ file_error::failure_to_open, path });</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    handle_ref h = make_handle(fd);</div>
<div class="line">    <span class="keywordtype">char</span> temp[1025];</div>
<div class="line">    ssize_t read = h-&gt;read(temp, 1024);</div>
<div class="line">    <span class="keywordflow">if</span>(-1 == read)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error{ file_error::io_failure, path });</div>
<div class="line">    temp[read] = 0;</div>
<div class="line">    <span class="keywordflow">if</span>(strchr(temp, 13) != <span class="keyword">nullptr</span>)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error{ file_error::format_corrupt, path });</div>
<div class="line">    <span class="keywordflow">return</span> h;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_alloc &amp;)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error{ file_error::out_of_memory, <span class="keyword">nullptr</span> });</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All other exceptions thrown upwards to abort</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> h = openfile(<span class="stringliteral">&quot;somefile&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (h)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;File opened successfully&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open file &quot;</span> &lt;&lt; h.error().path &lt;&lt; <span class="stringliteral">&quot; due to &quot;</span> &lt;&lt; h.error().code &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> So here we have a file open function which opens some path returning a reference counted handle to the open file and if that fails, it will return a custom error type with the path of the file which failed as its payload. As much as this is a simple example where the payload carried is just a pointer, you could actually transport any arbitrary data as your payload such as a stack backtrace etc.</p>
<p>Earlier we subclassed <code>std::error_code</code> to add in type safety to prevent the accidental return of errors not permitted by a function's specification. Here we take yet another approach, this time <em>embedding</em> a <code>std::error_code</code> inside our custom error type along with payload:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fcntl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span></div>
<div class="line"><span class="keyword">using</span> ssize_t = <span class="keywordtype">long</span> long;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>outcome = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// RAII for an open file handle</span></div>
<div class="line"><span class="keyword">class </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> _fd;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  handle() : _fd(-1) {}</div>
<div class="line">  handle(<span class="keywordtype">int</span> fd) : _fd(fd) {}</div>
<div class="line">  handle(handle &amp;&amp;o) noexcept : _fd(o._fd) { o._fd = -1; }</div>
<div class="line">  handle &amp;operator=(handle &amp;&amp;o) noexcept { this-&gt;~handle(); <span class="keyword">new</span>(<span class="keyword">this</span>) handle(std::move(o)); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line">  <span class="keyword">virtual</span> ~handle() { <span class="keywordflow">if</span> (-1 != _fd) ::close(_fd); }</div>
<div class="line">  ssize_t read(<span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> len) { return ::read(_fd, buffer, len); }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> handle_ref = std::shared_ptr&lt;handle&gt;;</div>
<div class="line"><span class="keyword">inline</span> handle_ref make_handle(<span class="keywordtype">int</span> fd) { <span class="keywordflow">return</span> std::make_shared&lt;handle&gt;(fd); }</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom error type</span></div>
<div class="line"><span class="keyword">enum class</span> extended_error</div>
<div class="line">{</div>
<div class="line">  format_corrupt</div>
<div class="line">};</div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">class </span>extended_error_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;extended_error&quot;</span>; }</div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (static_cast&lt;extended_error&gt;(c))</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> extended_error::format_corrupt:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;format corrupt&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::extended_error_category &amp;extended_error_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::extended_error_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>file_error</div>
<div class="line">{</div>
<div class="line">  std::error_code code;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *path;</div>
<div class="line">  file_error() : code(), path(nullptr) {}</div>
<div class="line">  <span class="comment">// Construct from a generic problem</span></div>
<div class="line">  file_error(std::errc problem, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path) : code(std::<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">make_error_code</a>(problem)), path(_path) {}</div>
<div class="line">  <span class="comment">// Construct from an errno</span></div>
<div class="line"><span class="preprocessor">#ifdef _MSC_VER  // On MSVC the POSIX open()/read() etc functions are generic_category</span></div>
<div class="line"><span class="preprocessor"></span>  file_error(<span class="keywordtype">int</span> _errno, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path) : code(_errno, std::<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx_1_1deatomiced__categories.html#a3f5465fc0be7c82b0c0b0bb5419ea59e">generic_category</a>()), path(_path) {}</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>  file_error(<span class="keywordtype">int</span> _errno, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path) : code(_errno, std::<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx_1_1deatomiced__categories.html#a9bd112823854cf5d6b347f1e14a02807">system_category</a>()), path(_path) {}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>  <span class="comment">// Construct from an extended error code</span></div>
<div class="line">  file_error(extended_error ec, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path) : code(static_cast&lt;int&gt;(ec), detail::extended_error_category()), path(_path) {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> outcome::expected&lt;handle_ref, file_error&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// NOTE that we lose no information here, whatever error the system returned is what we return</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error(errno, path));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    handle_ref h = make_handle(fd);</div>
<div class="line">    <span class="keywordtype">char</span> temp[1025];</div>
<div class="line">    ssize_t read = h-&gt;read(temp, 1024);</div>
<div class="line">    <span class="comment">// NOTE that we lose no information here, whatever error the system returned is what we return</span></div>
<div class="line">    <span class="keywordflow">if</span>(-1 == read)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error(errno, path));</div>
<div class="line">    temp[read] = 0;</div>
<div class="line">    <span class="keywordflow">if</span>(strchr(temp, 13) != <span class="keyword">nullptr</span>)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error(extended_error::format_corrupt, path));</div>
<div class="line">    <span class="keywordflow">return</span> h;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_alloc &amp;)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(file_error(std::errc::not_enough_memory, <span class="keyword">nullptr</span>));</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All other exceptions thrown upwards to abort</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> h = openfile(<span class="stringliteral">&quot;somefile&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (h)</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;File opened successfully&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open file &quot;</span> &lt;&lt; h.error().path &lt;&lt; <span class="stringliteral">&quot; due to &quot;</span> &lt;&lt; h.error().code &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> A nice consequence of this design is that the errors returned by the system calls are preserved perfectly rather than being converted into some generic "i/o failed" error code, and because we use <code>system_category</code> for the error codes returned by the host OS, we lose no information whatsoever about the original error. The failure to allocate memory is now returned using the standard error condition for that event, and the only error code which is truly bespoke <code>format_corrupt</code> gets its own custom error code category.</p>
<p>As much as the second example is much better design, it still has a custom error type the use of which precludes using convenience macros like <code>BOOST_OUTCOME_TRY</code> across disjoint domains of error. If that's acceptable to you, then work away, but be aware that Outcome's refinements of <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> don't use a <code>std::error_code</code>, they instead use an <code>outcome::error_code_extended</code> which extends <code>std::error_code</code> with most of the common payloads that most people would want to transmit along with their errors, such as a custom string.</p>
<p><code>error_code_extended</code> won't of course cover truly bespoke needs, and if you are finding your custom error type is getting richly featured enough to require <a href="http://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">a non-trivial destructor</a> then you should be aware that <code>expected&lt;T, E&gt;</code> must always use the lowest common denominator between <code>T</code> and <code>E</code>, so if your <code>E</code> has a non-trivial destructor, so will all <code>expected&lt;T, E&gt;</code>. This can mean that compilers will "blow out" code where such <code>expected&lt;T, E&gt;</code> is used i.e. generate a lot of code bloat. Again, if that's acceptable to you for your use case, then work away. But if that worries or bothers you, then you had best stick to trivial custom error types or better still, use Outcome's refinements of <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> which remove that choice entirely and give you in return a less boilerplate and more powerful programming experience. That is exactly the subject of Part C of this tutorial, next. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
