<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Expected&lt;T, E&gt; in Context</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_02-tutorial_a.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expected&lt;T, E&gt; in Context </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#c-style">C style error handling: integer returns</a></li>
<li class="level1"><a href="#cpp98-style">C++ 98 style error handling: throwing exceptions</a></li>
<li class="level1"><a href="#cpp11-style">C++ 11 style error handling: error_code and noexcept</a></li>
<li class="level1"><a href="#cpp17-style">C++ 17 style error handling: optional<T> and expected<T, E></a><ul><li class="level2"><a href="#optional">std::optional<T> (C++ 17)</a></li>
<li class="level2"><a href="#expected">std::experimental::expected<T, E> (on standards track)</a><ul><li class="level3"><a href="#sea_of_noexcept">Sea of noexcept, islands of exception throw</a></li>
<li class="level3"><a href="#bad_expected_access">Expected's bad_expected_access<E></a></li>
<li class="level3"><a href="#expected_observers">Expected's observers</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#expected_is_unstable">Expected is unstable!!!</a></li>
<li class="level1"><a href="#expected_example">Short example program using expected<T, E></a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial_expected"></a></p>
<p>Outcome's design rationale and tutorial is split into three parts:</p>
<ol type="1">
<li>The first part (part A, this part) provides a broad overview of error handling in C++ in general and how the <code>expected&lt;T, E&gt;</code> proposed for standardisation will contribute to that big menu of error handling design patterns available to the C++ programmer. This part places Outcome the library in context.</li>
<li>The second part (<a class="el" href="md_doc_md_03-tutorial_b.html#tutorial_whynot">part B</a>) describes some design anti-patterns common with inexperienced usage of <code>expected&lt;T, E&gt;</code> in C++ which you ought to avoid. It shows you how to use <code>expected&lt;T, E&gt;</code> in a way which integrates well with the C++ 11 STL's standard error code facilities <code>std::error_code</code> and <code>std::error_category</code>.</li>
<li>The third part (<a class="el" href="md_doc_md_04-tutorial_c.html#tutorial_outcome">part C</a>) walks you through using Outcome's <code>expected&lt;T, E&gt;</code> refinements <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, plus its <code>extended_error_code</code>. Usage is very similar to Expected, but with less typing, less runtime overhead and more convenient extensions.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="c-style"></a>
C style error handling: integer returns</h1>
<p>Historically C++ 98 code has taken one of two design patterns when returning errors from functions. This pattern is taken from C, and indeed is pure C:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">enum</span> errors</div>
<div class="line">{</div>
<div class="line">  SUCCESS=0,</div>
<div class="line">  NOMEM,</div>
<div class="line">  NOTFOUND,</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">extern <span class="keywordtype">int</span> openfile(<span class="keyword">struct</span> handle **outh, <span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  *outh = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> handle));</div>
<div class="line">  <span class="keywordflow">if</span>(!*outh)</div>
<div class="line">    <span class="keywordflow">return</span> NOMEM;</div>
<div class="line">  (*outh)-&gt;fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>((*outh)-&gt;fd == -1)</div>
<div class="line">  {</div>
<div class="line">    free(*outh);</div>
<div class="line">    *outh = NULL;</div>
<div class="line">    <span class="keywordflow">return</span> NOTFOUND;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Almost certainly anyone reading this has seen this error handling design umpteen times in their career. Variations on the same pattern are returning the enum type directly, returning a boolean and using a thread locally stored global variable such as <code>errno</code> and so on.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp98-style"></a>
C++ 98 style error handling: throwing exceptions</h1>
<p>The second C++ 98 design pattern ought to also be very familiar to readers:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line"><span class="keyword">extern</span> handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;File not found&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// RAII close the file if exception throw</span></div>
<div class="line">  handle temp(fd);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Could throw std::bad_alloc or any other kind of exception during construction</span></div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(temp));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Old hands will quite correctly chafe at the use of <code>std::runtime_error</code> to report a file not found, but nevertheless such a design pattern is very common in the wild, especially in older C++ which went a bit mad on using exception throws for control flow.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp11-style"></a>
C++ 11 style error handling: error_code and noexcept</h1>
<p>C++ 11 brought in two new features to help bridge the gap between the over use of exception throws to report routine failures and C error handling: (i) <code>noexcept</code> and (ii) the standardisation of <code>error_code</code> from Boost. <code>noexcept</code> lets you mark functions with the guarantee that they shall <b>never</b> throw exceptions. This is commonly described as a feature enabling the compiler and standard library to use faster algorithms which can assume that operations never need to be rolled back part way through, however it also enables a whole new way of writing C++ which we shall call <em>"islands of exception throw in a sea
of noexcept"</em> which will be described later.</p>
<dl class="section note"><dt>Note</dt><dd>In some C++ code, marking a function as <code>noexcept</code> has the additional semantic that "this function cannot fail". As the C++ standard does not say this about <code>noexcept</code> and functions marked <code>noexcept</code> can absolutely fail, just not throw exceptions out of themselves, we shall not assume that <code>noexcept</code> means functions marked so cannot fail.</dd></dl>
<p>Both the Boost and C++ 11 <code>error_code</code> consists of an integer and a reference to a singleton <code>error_category</code> instance. This allows one to set a <em>domain</em> for an integer error code such that <code>NOTFOUND</code> in library A can have a different integer value to <code>NOTFOUND</code> in library B. Because the reference to the domain of the error code is transported with the error code, integer error codes can be propagated <em>without losing information</em> into other code which need have no knowledge whatsover of libraries A nor B. <code>error_code</code> and the other machinery in <code>&lt;system_error&gt;</code> lets you handle errors from unknown libraries via <code>error_condition</code> which lets you inspect unknown third party <code>error_code</code>'s for whether they have semantic equivalence to the standard POSIX errors, and therefore handle a file-not-found situation based on semantic equivalence rather than losing information from the original source by doing an error code conversion. Therefore as with exception types deriving from <code>std::exception</code>, a central error handling routine can understand just enough of unknown third party error codes to act appropriately.</p>
<p>The fact that C++ 11's standard library can <em>unintrusively</em> do this with any arbitrary custom enum or integer error code system is not widely realised. It is hoped that Outcome helps make more people embrace this feature in their code (see tutorial part B).</p>
<p>The C++ 11 standard library makes very limited use of <code>error_code</code> for reporting errors, however the Filesystem TS and Networking TS as indeed much of Boost uses this error handling design pattern extensively:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-throwing overload</span></div>
<div class="line"><span class="keyword">extern</span> handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, std::error_code &amp;ec) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Construct an error code in the OS errors domain</span></div>
<div class="line">    ec = std::error_code(errno, <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx_1_1deatomiced__categories.html#a9bd112823854cf5d6b347f1e14a02807">std::system_category</a>());</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="comment">// Construct an error code matching the generic OS error equivalent</span></div>
<div class="line">    <span class="comment">// to the ENOMEM error condition</span></div>
<div class="line">    ec = <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::not_enough_memory);</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Throwing overload</span></div>
<div class="line"><span class="keyword">extern</span> handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  handle_ref ret(openfile(path, ec));</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::system_error(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This third error handling design pattern has two big advantages:</p>
<ol type="1">
<li>You only pay for what you use, so if you call the non-throwing overload you are guaranteed by the <code>noexcept</code> that execution flow will not unexpectedly invert. This makes writing correct exception safe code much easier, plus unpredictable execution times due to exception throws cannot occur. The compiler can also reduce executable bloat by not generating stack unwind tables around that call which is useful for some C++ users.</li>
<li>Simple usage of the API will default to the throwing (i.e. abort this operation) overload which is probably what most users <em>think</em> they want. This does have the advantage that the error won't be lost, however in practice aborting partially completed operations can lose other people's data just as easily as ignoring errors and proceeding regardless.</li>
</ol>
<p>Once you've been programming using the non-throwing API form for a while, some disadvantages begin to become obvious (which upcoming C++ 17/20 library additions will address):</p>
<ol type="1">
<li>It is clunky for callers of your function to have to create a <code>std::error_code</code> on the stack before calling the function passing in a lvalue ref. There is a temptation for programmers to reuse the <code>error_code &amp;ec</code> instance passed to their function, and this can become a source of unintended lost errors because errors already written there get overwritten or reset during error handling.</li>
<li>It is annoying having to type more boilerplate and remembering to check return codes just like in C. The compiler should be telling me when I forget to check an error, but the C++ 17 <code>[[nodiscard]]</code> attribute can't work with the lvalue ref passing pattern. This design pattern therefore suffers from the same problem as C style error codes, errors "get lost" or ignored inadvertently.</li>
<li>It might not seem a big thing until you see it in a large program, but having throwing and non-throwing variants of every API means doubling your API count. That means more maintenance, more testing, more documentation, more clutter.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp17-style"></a>
C++ 17 style error handling: optional&lt;T&gt; and expected&lt;T, E&gt;</h1>
<p>There are useful improvements coming in C++ 17/20 with which one can implement some new error handling design patterns in addition to those already covered above: </p>
<dl>
<dt><a href="http://en.cppreference.com/w/cpp/utility/optional"><code>std::optional&lt;T&gt;</code></a> </dt>
<dd>Utility class managing an optional contained value i.e. a value which may or may not be present. Available in C++ 17. </dd>
<dt><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0323r1.pdf"><code>std::experimental::expected&lt;T, E&gt;</code> (P0323R1)</a> </dt>
<dd>Utility class managing one of three variant states, an expected <code>T</code> or an unexpected <code>E</code> or valueless due to exception (with the valueless semantics matching <a href="http://en.cppreference.com/w/cpp/utility/variant"><code>std::variant&lt;...&gt;</code></a>). Currently expected to be available in C++ 20, if not then very likely in the following C++ standard. </dd>
</dl>
<h2><a class="anchor" id="optional"></a>
std::optional&lt;T&gt; (C++ 17)</h2>
<p>In some programming contexts we don't need to know why an operation failed, only that it did. Throwing an exception after failing to find a file is a good example of the kind of failure which is very common and where throwing an exception to handle that event is excessive and inappropriate. One might therefore design a routine expected to frequently fail in C++ as:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true for success and fills \em out with the opened file, else false</span></div>
<div class="line"><span class="keywordtype">bool</span> openfile(handle_ref &amp;out, <span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
</div><!-- fragment --><p>Wouldn't it be much nicer though if you didn't force the caller to have to instantiate a copy of <code>handle_ref</code> before each call, not least because such a requirement messes badly with using <code>openfile()</code> in generic template code and moreover it could be the case that constructing a <code>handle_ref</code> is an atomic operation, and is thus wasted work if the failure to open is very common? This is where <code>optional&lt;T&gt;</code> comes in:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the opened handle on success, else an empty optional</span></div>
<div class="line"><span class="keyword">extern</span> std::optional&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>optional&lt;T&gt;</code> is pretty boring and unsurprising like any good primitive. It's also fairly intuitive, almost any C++ programmer will immediately understand what the code above does from inspection.</p>
<h2><a class="anchor" id="expected"></a>
std::experimental::expected&lt;T, E&gt; (on standards track)</h2>
<p>Many familiar with the filesystem will find the above use case of <code>optional&lt;T&gt;</code> unsettling because there are many reasons why one couldn't open a file rather than merely it was not found. Imagine, for example, that a program is attempting to open a few thousand files on a networked drive which has broken its connection - in this case every single failure will take considerable time to return and there is zero chance <em>any</em> file open will ever succeed, so what the user sees is an apparently hanged program. Far better would be if the <code>openfile()</code> function could return the cause of its failure, and we could then treat all errors which are different to file-not-found as reason to <b>abort</b>.</p>
<p>This where the proposed <code>expected&lt;T, E&gt;</code> comes in. It refines <code>optional&lt;T&gt;</code> with variant storage which can hold either an expected value of type <code>T</code> or an unexpected value of type <code>E</code>. Like <code>variant&lt;T, E&gt;</code>, <code>expected&lt;T, E&gt;</code> is a discriminated union storing either <code>T</code> or <code>E</code> in the same storage space, but unlike the variant, expected treats the <code>T</code> as a positive thing (fetchable via a <code>.value()</code>) and <code>E</code> as a negative thing (fetchable via an <code>.error()</code>). Because <code>expected&lt;T, E&gt;</code> provides an "almost never empty" guarantee similar to variant, it currently requires type <code>E</code> to be nothrow copy and move constructible and assignable and default constructing an <code>expected&lt;T, E&gt;</code> will set its variant storage to a default constructed <code>T</code>, so <code>T</code> must be default constructible. Expected is a bit less intuitive to use than optional, but its rules are straightforward: <code>expected&lt;T, E&gt;</code> will greedily and implicitly construct from any type from which a <code>T</code> can be constructed, after which it will hold an instance of <code>T</code>. If you wish to construct an <code>expected&lt;T, E&gt;</code> holding an instance of unexpected <code>E</code>, you need to feed it an <code>unexpected_type&lt;E&gt;</code> which is type sugar to indicate you want an instance of <code>E</code> implicitly converted into an <code>expected&lt;T, E&gt;</code>. As with everything else in C++ 11 onwards, there is a <code>make_expected(T)</code> and a <code>make_unexpected(E)</code> which do any type deduction and conversion for you into the right contents of <code>expected&lt;T, E&gt;</code>.</p>
<p>All this sounds a bit complex, but really it's much easier to use. Here is a non-throwing implementation of <code>openfile()</code> based on <code>expected&lt;T, E&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line"><span class="keyword">extern</span> std::experimental::expected&lt;handle_ref, std::error_code&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">std::experimental::make_unexpected</a>(std::error_code(errno, <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx_1_1deatomiced__categories.html#a9bd112823854cf5d6b347f1e14a02807">std::system_category</a>());</div>
<div class="line">  }</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="comment">// C++ 11 lets you convert generic portable error_condition&#39;s into a platform</span></div>
<div class="line">    <span class="comment">// specific error_code like this</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">std::experimental::make_unexpected</a>(<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::not_enough_memory));</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// The some_derived_handle_implementation constructor failed</span></div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">std::experimental::make_unexpected</a>(std::move(ec));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);  <span class="comment">// expected&lt;&gt; takes implicit conversion to type T</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="comment">// C++ 11 lets you compare some platform specific error code to a generic</span></div>
<div class="line"><span class="comment">// portable error_condition</span></div>
<div class="line"><span class="keywordflow">if</span>(!fh_ &amp;&amp; fh_.error() != std::errc::no_such_file_or_directory)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// This is serious, abort by throwing a system_error wrapping the error code</span></div>
<div class="line">  <span class="keywordflow">throw</span> std::system_error(std::move(fh_.error()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>The part in the middle where we pass an <code>error_code &amp;</code> to the <code>some_derived_handle_implementation</code> constructor looks a bit weird. So let's rewrite the above to use the "sea of noexcept,
islands of exception throw" design pattern which is much more natural:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line"><span class="keyword">extern</span> std::experimental::expected&lt;handle_ref, std::exception_ptr&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = -1;</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    fd = open(path, O_RDONLY);</div>
<div class="line">    <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Convert errno into a platform specific error code and wrap that in a throw of a system error</span></div>
<div class="line">      <span class="keywordflow">throw</span> std::system_error(std::error_code(errno, <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx_1_1deatomiced__categories.html#a9bd112823854cf5d6b347f1e14a02807">std::system_category</a>()));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Implicit conversion to T (handle_ref)</span></div>
<div class="line">    <span class="keywordflow">return</span> make_handle_ref&lt;some_derived_handle_implementation&gt;(fd);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">      close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">std::experimental::make_unexpected</a>(std::current_exception());</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::rethrow_exception(fh_.error());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::system_error &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Ignore file not found errors</span></div>
<div class="line">    <span class="keywordflow">if</span>(e.code() != std::errc::no_such_file_or_directory)</div>
<div class="line">      <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All other exception types were rethrown</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>You'll note we've changed the error type from a <code>std::error_code</code> to a <code>std::exception_ptr</code> in order to transport, without losing information, all possible C++ exception throws.</p>
<h3><a class="anchor" id="sea_of_noexcept"></a>
Sea of noexcept, islands of exception throw</h3>
<p>The "sea of noexcept, islands of exception throw" design pattern is characterised by all <code>extern</code> function APIs i.e. all functions callable by code outside the current translation unit being marked <code>noexcept</code>. Because code outside the current translation unit will only see a header declaration of the form:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> std::experimental::expected&lt;handle_ref, std::exception_ptr&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
</div><!-- fragment --><p>... it is guaranteed by the C++ standard that calling that function will not throw an exception, and therefore invert the flow of execution. That makes writing exception safe code considerably easier in a lot of cases, which means lower maintenance and considerably fewer implicit potential execution paths to test for correctness.</p>
<p>Meanwhile internal to the implementation of <code>openfile()</code>, we do throw exceptions, but there is <b>always</b> a master <code>try...catch(...)</code> catchall clause at the base of the function. This is because if you have anything but a catchall try-catch, the compiler is required by the C++ standard to insert a call to <code>std::terminate()</code> if any exception throw reaches a noexcept function boundary. Assuming that you really don't want that to happen, we therefore always catch all exceptions and convert them into a <code>std::exception_ptr</code> which we return out of the function via the normal value return mechanism as an unexpected Expected instance.</p>
<dl class="section note"><dt>Note</dt><dd>Old hands would consider any use of <code>exception_ptr</code> to be similarly heavyweight to any use of <code>std::shared_ptr</code> as they need to be implemented the same way (i.e. with malloc and atomics) according to the C++ standard. For most code this is an acceptable overhead, if that is not the case in your code then Tutorial part B is for you.</dd></dl>
<p>Finally, within any translation unit you do NOT mark non-extern functions with <code>noexcept</code> unless the function cannot fail. Because the compiler can see an entire translation unit as a single whole, it will deduce which non-extern functions can throw and which can not (any calls by you into other translation units will use extern functions marked <code>noexcept</code>, hence the only exception throws which the compiler needs to consider will be thrown from within the current translation unit only). The compiler ought to then optimise the current translation unit down to an <b>optimal</b> edition maximising the regions of code known by the compiler to be incapable of throwing exceptions, thus eliminating any EH tables etc for that code. Indeed, if the master catchall try-catch at the base of an extern function is deduced by the compiler to not be needed, all recent compilers will eliminate that from the runtime code generated too, effectively making it as if you compiled the translation unit with C++ exceptions globally disabled.</p>
<h3><a class="anchor" id="bad_expected_access"></a>
Expected's bad_expected_access&lt;E&gt;</h3>
<p>The proposed Expected implementation defines this exception type to represent when you try to use an <code>expected&lt;T, E&gt;</code> in a way not compatible with its current state:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt; <span class="keyword">class </span>bad_expected_access : <span class="keyword">public</span> std::logic_error</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> error_type = E;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">explicit</span> bad_expected_access(<span class="keyword">const</span> error_type &amp;e) noexcept;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> error_type &amp;<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() const &amp; noexcept;</div>
<div class="line">  error_type &amp;<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() &amp; noexcept;</div>
<div class="line">  const error_type &amp;&amp;<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() const &amp;&amp; noexcept;</div>
<div class="line">  error_type &amp;&amp;<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() &amp;&amp; noexcept;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is currently an extension to the proposal by Outcome, but we think it highly</span></div>
<div class="line"><span class="comment">// likely to be in the next revision of the proposal</span></div>
<div class="line">template &lt;&gt; class bad_expected_access&lt;<span class="keywordtype">void</span>&gt; : public std::logic_error</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> error_type = void;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">explicit</span> bad_expected_access() noexcept;</div>
<div class="line">};</div>
</div><!-- fragment --><p>So for example, if you tried to get the value of an Expected when it was errored, you would see this:</p>
<div class="fragment"><div class="line">std::experimental::expected&lt;int, std::error_code&gt; a(<a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">std::experimental::make_unexpected</a>(<a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::no_such_file_or_directory)));</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// a is errored, so this will throw</span></div>
<div class="line">  a.value();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::experimental::bad_expected_access&lt;std::error_code&gt; &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// expected throws a bad_expected_access&lt;E&gt; with the current value of the E</span></div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Expected throws bad_expected_access with error &quot;</span> &lt;&lt; e.error() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0323r1.pdf">most recent proposal for Expected (P0323R1)</a> added the valueless by exception state from Variant, so if a move or copy constructor or assignment throws, like Variant Expected is left in an intermediate "valueless" state. The current proposal isn't clear what ought to happen when you try to get a value or error from such a valueless Expected instance, so Outcome has chosen to throw a <code>bad_expected_access&lt;void&gt;</code> exception when Expected is valueless. We expect the standards proposal to do something similar next revision, if not we will update Outcome's Expected implementation to match.</p>
<h3><a class="anchor" id="expected_observers"></a>
Expected's observers</h3>
<p>Generally speaking you will not want Expected to throw <code>bad_expected_access&lt;E&gt;</code> as a try-catch cycle is a lot less efficient than simply asking an <code>expected&lt;T, E&gt;</code> instance what state it has before accessing it. Expected has the following highly unsurprising observers with standard STL semantics and meaning matching those in <code>std::optional&lt;T&gt;</code> and <code>std::variant&lt;...&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> E&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> value_type = T;</div>
<div class="line">  <span class="keyword">using</span> error_type = E;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;</div>
<div class="line">    <span class="keyword">struct </span>rebind {</div>
<div class="line">      <span class="keyword">using</span> type = expected&lt;U, error_type&gt;;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// As if &amp;value()</span></div>
<div class="line">  constexpr <span class="keyword">const</span> T* operator -&gt;() <span class="keyword">const</span>;</div>
<div class="line">  T* operator -&gt;();</div>
<div class="line">  <span class="comment">// As if value()</span></div>
<div class="line">  constexpr <span class="keyword">const</span> T&amp; operator *() const&amp;;</div>
<div class="line">  T&amp; operator *() &amp;;</div>
<div class="line">  constexpr const T&amp;&amp; operator *() const &amp;&amp;;</div>
<div class="line">  constexpr T&amp;&amp; operator *() &amp;&amp;;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// True if and only if currently storing a value_type</span></div>
<div class="line">  constexpr explicit operator <span class="keywordtype">bool</span>() const noexcept;</div>
<div class="line">  constexpr <span class="keywordtype">bool</span> has_value() const noexcept;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Returns a lvalue or rvalue ref to the stored value_type if there is one, else throws a bad_expected_access&lt;E&gt;</span></div>
<div class="line">  constexpr const T&amp; <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab1740f6220ea9c91b5fd5a9263c6b316">value</a>() const&amp;;</div>
<div class="line">  constexpr T&amp; <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#ab1740f6220ea9c91b5fd5a9263c6b316">value</a>() &amp;;</div>
<div class="line">  constexpr const T&amp;&amp; value() const &amp;&amp;;</div>
<div class="line">  constexpr T&amp;&amp; value() &amp;&amp;;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Returns a lvalue or rvalue ref to the stored error_type if there is one, else undefined behaviour</span></div>
<div class="line">  constexpr const E&amp; <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() const&amp;;</div>
<div class="line">  E&amp; <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a1a1a8470c4efc3a52412f3ecc79a0060">error</a>() &amp;;</div>
<div class="line">  constexpr E&amp;&amp; error() &amp;&amp;;</div>
<div class="line">  constexpr const E&amp;&amp; error() const &amp;&amp;;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Returns the stored error_type as an unexpected_type&lt;E&gt; if there is one, else undefined behaviour</span></div>
<div class="line">  constexpr <a class="code" href="group__expected.html#gaf61cb3012566f621329133c01f17c647">unexpected_type</a>&lt;E&gt; get_unexpected() const;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If currently storing a value_type, returns that, else the parameter passed  </span></div>
<div class="line">  template &lt;class U&gt;</div>
<div class="line">    constexpr T value_or(U&amp;&amp;) const&amp;;</div>
<div class="line">  template &lt;class U&gt;</div>
<div class="line">    T value_or(U&amp;&amp;) &amp;&amp;;</div>
<div class="line"></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You should be aware that Outcome's Expected implementation varies from the above in a few very minor ways. It also provides a considerable number of extensions. See <a class="el" href="md_doc_md_08-expectedsynopsis.html#outcome_expected_reference">Outcome's implementation of Expected</a> for an exact detail.</dd></dl>
<p>As inferred in the example code cases earlier, you can check if an <code>expected&lt;T, E&gt;</code> has an expected value via a simple test for boolean true or more explicitly via <code>.has_value()</code> before retrieving the value using <code>.value()</code>. A useful shortcut can be <code>.value_or()</code> where you would otherwise write a ternary operation selecting on the Expected having an expected value.</p>
<p>Finally, the current proposal before WG21 has not yet added a mechanism for testing if the Expected is valueless or not, so you currently have no way of testing for that except by catching the exception thrown. It <em>may</em> mirror <code>std::variant&lt;...&gt;</code>'s <code>valueless_by_exception()</code> observer function, or it may choose something else. Outcome's implementation of Expected implements a '.empty()' extension, this seemed to fit the rest of STL the best.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_is_unstable"></a>
Expected is unstable!!!</h1>
<p>Before we say or do anything else, we need to clearly state:</p>
<dl class="section warning"><dt>Warning</dt><dd>Outcome's implementation of Expected WILL track the LEWG Expected proposal. No API backwards compatibility will be maintained, so if proposed LEWG Expected breaks your code, so will Outcome's Expected.</dd></dl>
<p>If you would like to use a stable API, Outcome's refinements of <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> are expected to be API stable, or else pin yourself to an older git SHA revision of the Outcome library.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_example"></a>
Short example program using expected&lt;T, E&gt;</h1>
<p>Up until now we have been referring to Expected via the namespace <code>std::experimental</code>. Outcome obviously does not provide Expected in that namespace, instead it uses the outcome namespace which you can find via either of these forms:</p>
<div class="fragment"><div class="line"><span class="comment">// Traditional: use SOME version Boost.Outcome visible to the compiler/linker</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#aab2ff6220205017226794529c863b336">outcome</a> = <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#aab2ff6220205017226794529c863b336">boost::outcome</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Better: use EXACTLY the Boost.Outcome visible in the current translation unit</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#aab2ff6220205017226794529c863b336">outcome</a> = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
</div><!-- fragment --><p>The <code>BOOST_OUTCOME_V1_NAMESPACE</code> macro encodes a unique hexadecimal value per release. This guarantees that the linker will not substitute a different version of Outcome than the Outcome you compiled against. It is therefore recommended that you use the <code>BOOST_OUTCOME_V1_NAMESPACE</code> macro.</p>
<p>This example program using <code>expected&lt;T, E&gt;</code> replicates <a href="http://rustbyexample.com/std/result.html">the use example in the documentation for Rust's <code>Result&lt;T, E&gt;</code></a>. As you will see in Tutorial part B, you would be unwise to use <code>expected&lt;T, E&gt;</code> like this in large C++ programs.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#aab2ff6220205017226794529c863b336">outcome</a> = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Replicates example usage of Result&lt;T, E&gt; from http://rustbyexample.com/std/result.html</span></div>
<div class="line"><span class="keyword">namespace </span>checked</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Mathematical &quot;errors&quot; we want to catch</span></div>
<div class="line">  <span class="keyword">enum class</span> MathError {</div>
<div class="line">    DivisionByZero,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    NegativeSquareRoot</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">using</span> MathResult = outcome::expected&lt;double, MathError&gt;;</div>
<div class="line">  </div>
<div class="line">  MathResult div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">      <span class="comment">// the failure wrapped in E</span></div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError::DivisionByZero);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">      <span class="keywordflow">return</span> x / y;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  MathResult sqrt(<span class="keywordtype">double</span> x) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(x &lt; 0.0)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError::NegativeSquareRoot);</div>
<div class="line">    return ::sqrt(x);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  MathResult ln(<span class="keywordtype">double</span> x) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(x &lt; 0.0)</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga65f63cc3d21288cf48f31096b10c2b0b">outcome::make_unexpected</a>(MathError::NegativeLogarithm);</div>
<div class="line">    return ::log(x);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> op(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Outcome provides a .match() extension, but this is 100% standard Expected</span></div>
<div class="line">  <span class="comment">// Also using outcome::result&lt;T&gt; instead of expected&lt;T, E&gt; would enable</span></div>
<div class="line">  <span class="comment">// intelligent printing of the error code to std::cerr</span></div>
<div class="line">  checked::MathResult ratio = checked::div(x, y);</div>
<div class="line">  <span class="keywordflow">if</span>(!ratio)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;PANIC: MatchResult::DivisionByZero&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::terminate();</div>
<div class="line">  }</div>
<div class="line">  checked::MathResult ln = checked::ln(*ratio);</div>
<div class="line">  <span class="keywordflow">if</span>(!ln)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;PANIC: MatchResult::NegativeLogarithm&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::terminate();</div>
<div class="line">  }</div>
<div class="line">  checked::MathResult sqrt = checked::sqrt(*ln);</div>
<div class="line">  <span class="keywordflow">if</span>(!sqrt)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;PANIC: MatchResult::NegativeSquareRoot&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    std::terminate();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> sqrt.value();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Will this fail?</span></div>
<div class="line">  std::cout &lt;&lt; op(1.0, 10.0) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
